<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
    <meta name="generator" content="HTML Tidy for Windows (vers 1st November 2003), see www.w3.org" />
    <title>HPX Parallel Sort</title>
    <link href="files/code.css" type="text/css" rel="stylesheet" />
  </head>
  <!--***************************************************************************************** -->
  <!--                                        B O D Y                                           -->
  <!--***************************************************************************************** -->
  <body>
    <div class="cuerpo_central"> <br />
      <div class="cuerpo_texto">
        <h1 class="heading-title"><img src="files/hpx.png" alt="" title="HPX title" />  
          </h1> <br />
        <span style="font-size: 32pt;"> <span style="font-weight: bold; color: black;">
          </span><span style="color: black;"><a href="index.html">The HPX
              Parallel Sort Library</a> </span></span><br />
        <div>
          <div class="author">
            <h2><span style="font-weight: normal; font-style: italic;"><a href="https://github.com/fjtapia/HPX_sort"
                  target="_blank">( https://github.com/fjtapia/HPX_sort )</a></span></h2>
            <h3 class="author"> <span class="firstname"></span></h3>
            <h3 style="font-style: italic;" class="author"><span style="font-weight: normal;"><span
                  class="firstname">Francisco Jose Tapia</span>   Copyright ©
                2016 Francisco Jose Tapia</span></h3>
          </div>
        </div>
        <div>
          <div class="legalnotice">
            <p><span style="font-style: italic;">Distributed under the Boost
                Software License, Version 1.0. (See accompanying file
                LICENSE_1_0.txt or copy at </span><a style="font-style: italic;"
                href="file:///LICENSE_1_0.txt" target="_top">
                http://www.boost.org/LICENSE_1_0.txt </a><span style="font-style: italic;">)</span>
            </p>
          </div>
        </div>
        <br />
        <br />
        <div class="caja_menu"> <span style="font-size: 16pt;font-weight: bold; color: black;"><br />
            Table of Contents</span> <br />
          <br />
          <div style="margin-left: 40px;">
            <div style="margin-left: 40px;"><a href="index.html#Introduction">1.-
                Introduction</a><br />
            </div>
            <div style="margin-left: 40px;"><br />
              <a href="index.html#algorithms">2.- </a><a href="file:///home/francisco/Projects/Sort/Hpx_dev/doc/index.html#thread">
                Creating Index ( less_ptr_no_null) </a>
              <div style="margin-left: 40px;"><br />
              </div>
              3<a href="benchmark.html#benchmarks">.- Benchmarks</a> <br />
              <div style="margin-left: 40px;"> <a href="benchmark.html#linux">3.1.-
                  Linux 64 bits GCC 4.9.</a><br />
              </div>
            </div>
            <div style="margin-left: 40px;">
              <div style="margin-left: 80px;"><a href="benchmark.html#linux_integer">3.1.1.-
                  Integer benchmarks </a><br />
                <a href="benchmark.html#linux_string">3.1.2.- Strings benchmarks</a><br />
                <a href="benchmark.html#linux_object">3.1.3.- Objects benchmarks</a>
              </div>
              <div style="margin-left: 40px;"> <br />
                <a href="benchmark.html#windows">3.2.- Windows7 64 bits Visual
                  Studio 2015</a><br />
                <div style="margin-left: 40px;"> <a href="benchmark.html#windows_integer">3.2.1.-
                    Integer benchmarks </a><br />
                  <a href="benchmark.html#windows_string">3.2.2.- Strings
                    benchmarks</a><br />
                  <a href="benchmark.html#windows_object">3.2.3.- Objects
                    benchmarks</a></div>
              </div>
              <br />
              <a href="html/index.html">4.- Source code documentation  </a><br />
              <br />
              <a href="benchmark.html#references">5.- References and
                Acknowledgements  </a><br />
              <br />
            </div>
          </div>
        </div>
        <br />
        <br />
        <p><a name="Introduction"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.-
            Introduction</span></p>
        <p> The<a target="_blank" title=" HPX Parallel Sort" href="https://github.com/fjtapia/HPX_sort">
            HPX parallel sort</a>, had been designed for to be included in the <a
            href="https://github.com/STEllAR-GROUP/hpx" data-original-href="https://github.com/STEllAR-GROUP/hpx">HPX
            Library</a></p>
        <p>HPX is a general purpose C++ runtime system for parallel and
          distributed applications of any scale. The goal of HPX is to create a
          high quality, freely available, open source implementation of the
          ParalleX model for conventional systems, such as classic Linux based
          Beowulf clusters or multi-socket highly parallel SMP nodes.</p>
        <p>This library provide the sorting algorithms in a single thread and
          parallel versions for that Library.</p>
        <p>The algorithms <strong>use an comparison object</strong>, in the
          same way than the sort algorithms of the standard library. If you
          don't define it, by default is std::less object, using internally the
          operator &lt; for to do the comparison.</p>
        <p>The algorithms are <strong>exception safe</strong>, it means, the
          exceptions generated by the algorithms guarantee the integrity of the
          objects to sort , but not their relative order. If the exception is
          generated inside the objects (in the move or in the copy constructor..
          ) the results can be unpredictable. </p>
        <p>For to select the single thread and the parallel version, these
          algorithms use the execution policy, as described in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4071.htm"
            data-original-href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4071.htm">Working
            Draft, Technical Specification for C++ Extensions for Parallelism</a>
          . If you want a simplified version you can find in <a href="http://en.cppreference.com/w/cpp/experimental/parallelism"
            data-original-href="http://en.cppreference.com/w/cpp/experimental/parallelism">cpp
            reference</a>.</p>
        <p>For the single thread version, pass as first parameter <code><span style="font: 10pt Monospace;"><span
                class="style11">hpx</span><span class="style10">::</span><span class="style11">parallel</span><span
                class="style10">::</span><span class="style11">v1</span><span class="style10">::</span><span
                class="style11">seq ,</span></span></code>and for the parallel
          version <code><span class="style5" style="font: 9pt Monospace;"><span
                class="style5"><code><span style="font: 10pt Monospace;"><span class="style11">hpx</span><span
                      class="style10">::</span><span class="style11">parallel</span><span
                      class="style10">::</span><span class="style11">v1</span><span
                      class="style10">::</span><span class="style11">par</span><span
                      class="style10"></span></span></code></span></span></code></p>
        <div class="caja_codigo">
          <pre><code><span class="style5" style="font: 9pt Monospace;"><span class="style5"><br /></span></span></code><br /><code><span
style="font: 10pt Monospace;"><span class="style2">//----------------------------------------------------------------------------
</span><span class="style15">// Non stable sort single thread<br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//-----------------------------------------------------------------------------</span></span></code><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style11">hpx::parallel::sort</span><span class="style10">::</span><span class="style16">sort </span><span
class="style10">(</span><span class="style11">hpx</span><span class="style10">::</span><span
class="style11">parallel</span><span class="style10">::</span><span class="style11">v1</span><span
class="style10">::</span><span class="style11">seq</span><span class="style10">, </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">begin</span><span
class="style10">() , </span><span class="style11">A</span><span class="style10">.</span><span
class="style16">end</span><span class="style10">(), </span><span class="style11">comp </span><span
class="style10">);</span></span></code><br /><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//----------------------------------------------------------------------------
</span><span class="style15">// Non stable sort, parallel<br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//-----------------------------------------------------------------------------</span></span></code><br /></span></span></code></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span class="style5" style="font: 9pt Monospace;"><span
class="style5"><code><span style="font: 10pt Monospace;"><span class="style11">hpx::parallel::sort</span><span
class="style10">::</span><span class="style16">sort </span><span class="style10">(</span><span
class="style11">hpx</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">::</span><span class="style11">v1</span><span class="style10">::</span><span
class="style11">par</span><span class="style10">, </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">comp </span><span class="style10">);</span></span></code></span></span></code><br /><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//----------------------------------------------------------------------------
</span><span class="style15">// Stable sort single thread<br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//-----------------------------------------------------------------------------</span></span></code></span></span></code><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span class="style5" style="font: 9pt Monospace;"><span
class="style10"><code><span style="font: 10pt Monospace;"><span class="style11">hpx::parallel::sort</span><span
class="style10">::</span><span class="style16">stable_sort </span><span class="style10">(</span><span
class="style11">hpx</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">::</span><span class="style11">v1</span><span class="style10">::</span><span
class="style11">seq</span><span class="style10">,</span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">comp  </span><span class="style10">);</span></span></code></span></span></code><br /><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style15"><code><span style="font: 10pt Monospace;"><span class="style2">//----------------------------------------------------------------------------
</span><span class="style15">// Stable sort, parallel<br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//-----------------------------------------------------------------------------</span></span></code></span></span></code></span></span></code><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span class="style5" style="font: 9pt Monospace;"><span
class="style10"><code><span style="font: 10pt Monospace;"><span class="style11">hpx::parallel::sort</span><span
class="style10">::</span><span class="style16">stable_sort </span><span class="style10">(</span><span
class="style11">hpx</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">::</span><span class="style11">v1</span><span class="style10">::</span><span
class="style11">par</span><span class="style10">,</span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">() , </span><span class="style11">comp</span><span class="style10">);</span></span></code></span></span></code><br /><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style15"><code><span style="font: 10pt Monospace;"><span class="style15"><code><span
style="font: 10pt Monospace;"><span class="style2">//----------------------------------------------------------------------------
</span><span class="style15">// Sample sort, stable sort, parallel faster than stable sort parallel, but need<br />// more memory<br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style15"><code><span style="font: 10pt Monospace;"><span
class="style2">//-----------------------------------------------------------------------------</span></span></code></span></span></code></span></span></code></span></span></code><br /></span></span></code><code><span
style="font: 10pt Monospace;"><span class="style11">hpx::parallel::sort</span><span
class="style10">::</span><span class="style11">sample_sort </span><span class="style10">(</span><span
class="style11">hpx</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">::</span><span class="style11">v1</span><span class="style10">::</span><span
class="style11">par</span><span class="style10">,</span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">comp </span><span class="style10">);<br /><br /></span></span></code></pre>
          <span class="style9"> </span> </div>
        <p><br />
        </p>
        <p><strong>This library is include only</strong>. Don't need to link
          with any static or dynamic library. Don't have dependence of any other
          files, variables or libraries or any other external libraries. For to
          use, only need a to include the files of the boost/sort/parallel
          folder, any more.</p>
        <p>This table provide you a brief description of the sort algorithms of
          the library.</p>
        <table>
          <thead>
            <tr>
              <th>Algorithm</th>
              <th>Parallel</th>
              <th>Stable</th>
              <th>Additional memory</th>
              <th>Best, average, and worst case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>sort</td>
              <td>no</td>
              <td>no</td>
              <td>Log N</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>stable_sort</td>
              <td>no</td>
              <td>yes</td>
              <td>N / 2</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>sort</td>
              <td>yes</td>
              <td>no</td>
              <td>1024*NThreads</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>stable_sort</td>
              <td>yes</td>
              <td>yes</td>
              <td>N / 2</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>sample_sort</td>
              <td>yes</td>
              <td>yes</td>
              <td>N</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
          </tbody>
        </table>
        <p>In this Parallel library, you can find <strong>stable and not stable
            sort</strong> algorithms, in a <strong>single thread and parallel</strong>
          version.</p>
        This version have a <strong>new non stable parallel_sort algorithm</strong>
        <em>( internally named Block Indirect)</em>, created for processors
        connected with <strong>shared memory</strong>.
        <p>In the parallel sorting algorithms, we can find algorithms <strong>fast
            with a small number of threads</strong>, but with a great number of
          HW threads , show their lacks</p>
        <ul>
          <li>Intel Threading Building Blocks (TBB)</li>
          <li>Microsoft PPL Parallel Sort).</li>
        </ul>
        <p>And others not so fast with small number of HW threads, and <strong>fast
            with many threads</strong>. These algorithms use an additional
          memory of the same size than the data.</p>
        <ul>
          <li>GCC Parallel Sort (based on OpenMP)</li>
          <li>Microsoft PPL Parallel Buffered Sort</li>
        </ul>
        <p>This generate an <strong>undesirable duality</strong>. With a small
          number of threads use one algorithm, and with a big number use other.
          Due this, the SW designed for a small machine is inadequate for a big
          machine and vice versa. But the main problem, for the algorithms for a
          big number of HW threads is the memory used, usually of the same size
          than the data.</p>
        <p>This <strong>new parallel sort algorithm</strong> permit <strong>eliminate
            the duality</strong>. With <strong>many threads</strong>, have
          similar performance than GCC Parallel Sort, and with <strong>a few
            threads</strong> have similar performance than TBB, with the <strong>additional
            advantage</strong> of the <strong>small memory consumption</strong>.</p>
        <p>The algorithm use as <strong>auxiliary memory a 1024 elements</strong>
          for each thread. The <span style="font-weight: bold;">worst case</span>
          for the algorithm is when have <span style="font-weight: bold;">very
            big element</span>s and <span style="font-weight: bold;">many
            threads</span>. With big elements (512 bytes), and 32 threads, The
          memory measured was:</p>
        <table>
          <thead>
            <tr>
              <th>Algorithm</th>
              <th>Memory used in MB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GCC Parallel Sort (OpenMP)</td>
              <td>1565 MB</td>
            </tr>
            <tr>
              <td>Threading Building Blocks (TBB)</td>
              <td>783 MB</td>
            </tr>
            <tr>
              <td>Block Indirect Sort</td>
              <td>814 MB</td>
            </tr>
          </tbody>
        </table>
        <em><br />
          This <strong>new parallel_sort algorithm had been created and
            implemented specifically for this library</strong> by the author.</em><br />
        <p> <em>If you are interested in a <span style="font-weight: bold;">brief
              description</span> of the algorithm, you can find in the next link</em>
          <a href="../block_indirect_sort_brief_en.pdf" target="_blank" data-original-href="../block_indirect_sort_brief_en.pdf">
            Block Indirect Sort Brief </a> <br />
          <em>If you are interested in a <span style="font-weight: bold;">detailed
              description</span> of the algorithm, you can find in the next link</em>
          <a target="_blank" href="../block_indirect_sort_en.pdf" data-original-href="../block_indirect_sort_en.pdf">
            Block Indirect Sort </a><br />
        </p>
        <br />
        <p><a name="thread"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">2.-
            Creating index ( </span><span style="font-size: 18pt;font-weight: bold; color: black;"><span
              style="font-size: 16pt;font-weight: bold; color: black;">
              less_ptr_no_null </span>)<br />
          </span></p>
        <br />
        Sometimes, we don't want   sort the data, but we want create en index,
        which is  a collection of iterators or pointers , sorted by the value
        pointed by them.<br />
        <br />
        For to create a index, we have a special comparison object
        less_ptr_no_null , defined in the hpx/parallel/sort/sort.hpp file in the
        nanmespace hpx::parallel::sort namespace, which permit call to the sort
        functions with the pointers to the iterators and itself as comparison
        object<br />
        <br />
        <br />
        <div class="caja_codigo"> <br />
          <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style2">//---------------------------------------------------------------------------
</span><span class="style15">/// </span><span class="style17">@class </span><span
class="style15">less_ptr_no_null
///
/// </span><span class="style17">@remarks </span><span class="style15">this is the comparison object for pointers. Receive a object
///          for to compare the objects pointed. The pointers can't be nullptr
</span><span class="style2">//---------------------------------------------------------------------------
</span><span class="style5">template    </span><span class="style10">&lt;   </span><span
class="style5">class </span><span class="style11">iter_t </span><span class="style10">,
                </span><span class="style5">class </span><span class="style11">comp_t
                </span><span class="style10">=</span><span class="style16">std</span><span
class="style10">::</span><span class="style16">less</span><span class="style10">&lt;</span><span
class="style5">typename </span><span class="style16">iterator_traits</span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">&gt;::</span><span
class="style16">value_type</span><span class="style10">&gt; &gt;
</span><span class="style5">struct </span><span class="style11">less_ptr_no_null
</span><span class="style10">{   </span><span class="style2">//----------------------------- Variables -----------------------
    </span><span class="style11">comp_t comp </span><span class="style10">;
    </span><span class="style2">//----------------------------- Functions ----------------------
    </span><span class="style5">inline </span><span class="style11">less_ptr_no_null </span><span
class="style10">( </span><span class="style11">comp_t C1 </span><span class="style10">= </span><span
class="style11">comp_t</span><span class="style10">()):</span><span class="style11">comp</span><span
class="style10">(</span><span class="style11">C1</span><span class="style10">){};<br />   <br />    </span><span
class="style5">inline bool operator </span><span class="style10">()( </span><span
class="style11">iter_t  T1</span><span class="style10">,  </span><span class="style11">iter_t  T2 </span><span
class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style2"></span><span class="style5">return  </span><span
class="style11">comp</span><span class="style10">(*</span><span class="style11">T1 </span><span
class="style10">,*</span><span class="style11">T2</span><span class="style10">);
    };
};</span></span></code></pre>
          <br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <img align="justify" src="file:///home/francisco/Projects/Sort/Boost_dev/doc/img/paso3.png"
          alt="" /><br />
        With an example, you will understand. We have a registers sorted by the
        num field , but create an index for to have the elements sorted by name,
        and other for to have sorted by weight. Create the less_ptr_no_null
        comparison objects, and sort the index. After all , print the results<br />
        <br />
        <br />
        <div class="caja_codigo"> <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style9">#include &lt;hpx/hpx.hpp&gt;
#include &lt;hpx/hpx_init.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;cassert&gt;

#include &lt;hpx/parallel/sort/sort.hpp&gt;

</span><span class="style5">using namespace </span><span class="style16">std </span><span
class="style10">;
</span><span class="style5">namespace </span><span class="style11">hpx_sort </span><span
class="style10">= </span><span class="style11">hpx</span><span class="style10">::</span><span
class="style11">parallel</span><span class="style10">::</span><span class="style16">sort </span><span
class="style10">;
</span><span class="style5">using </span><span class="style11">hpx_sort</span><span
class="style10">::</span><span class="style11">less_ptr_no_null </span><span class="style10">;

</span><span class="style5">struct </span><span class="style11">member
</span><span class="style10">{   </span><span class="style5">uint32_t </span><span
class="style11">num </span><span class="style10">;
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">string </span><span class="style11">name</span><span class="style10">;
    </span><span class="style5">float </span><span class="style11">weight</span><span
class="style10">;
};
</span><span class="style5">typedef typename </span><span class="style16">vector</span><span
class="style10">&lt;</span><span class="style11">member</span><span class="style10">&gt;::</span><span
class="style16">iterator </span><span class="style11">iter_t </span><span class="style10">;

</span><span class="style5">struct </span><span class="style11">cmp_num
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">num </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">num</span><span class="style10">); };
};

</span><span class="style5">struct </span><span class="style11">cmp_name
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">)</span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">name </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">name</span><span class="style10">); };
};

</span><span class="style5">struct </span><span class="style11">cmp_weight
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">weight </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">weight</span><span class="style10">); };
};

</span><span class="style11">ostream </span><span class="style10">&amp; </span><span
class="style5">operator </span><span class="style10">&lt;&lt; ( </span><span class="style11">ostream </span><span
class="style10">&amp; </span><span class="style11">out</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m</span><span class="style10">)
{   </span><span class="style11">out</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">num</span><span
class="style10">&lt;&lt;</span><span class="style6">" - "</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">name</span><span
class="style10">&lt;&lt;</span><span class="style6">" - "</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">weight</span><span
class="style10">&lt;&lt;</span><span class="style16">endl</span><span class="style10">;
    </span><span class="style5">return </span><span class="style11">out </span><span
class="style10">;
};

</span><span class="style5">int </span><span class="style11">main</span><span class="style10">(</span><span
class="style5">int </span><span class="style11">argc</span><span class="style10">, </span><span
class="style5">char</span><span class="style10">* </span><span class="style11">argv</span><span
class="style10">[])
{
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">vector</span><span class="style10">&lt;</span><span class="style16">std</span><span
class="style10">::</span><span class="style16">string</span><span class="style10">&gt; </span><span
class="style11">cfg</span><span class="style10">;
    </span><span class="style11">cfg</span><span class="style10">.</span><span class="style16">push_back</span><span
class="style10">(</span><span class="style6">"hpx.os_threads=1"</span><span class="style10">);

    </span><span class="style2">// Initialize and run HPX.
    </span><span class="style5">return </span><span class="style11">hpx</span><span
class="style10">::</span><span class="style11">init</span><span class="style10">(</span><span
class="style11">argc</span><span class="style10">, </span><span class="style11">argv</span><span
class="style10">, </span><span class="style11">cfg</span><span class="style10">);

}
</span><span class="style5">int </span><span class="style11">hpx_main</span><span
class="style10">(</span><span class="style16">boost</span><span class="style10">::</span><span
class="style11">program_options</span><span class="style10">::</span><span class="style11">variables_map</span><span
class="style10">&amp;)
{   </span><span class="style2">//------------------------ begin -----------------------
    // The data are sorted by number
    </span><span class="style16">vector</span><span class="style10">&lt;</span><span
class="style11">member</span><span class="style10">&gt; </span><span class="style11">VM </span><span
class="style10">= { {</span><span class="style4">1</span><span class="style10">,</span><span
class="style6">"Peter"</span><span class="style10">,</span><span class="style4">85.6</span><span
class="style10">},   {</span><span class="style4">2</span><span class="style10">,</span><span
class="style6">"Hanna"</span><span class="style10">, </span><span class="style4">63.4 </span><span
class="style10">},
                          {</span><span class="style4">3</span><span class="style10">,</span><span
class="style6">"John"</span><span class="style10">, </span><span class="style4">83.6</span><span
class="style10">},   {</span><span class="style4">4</span><span class="style10">,</span><span
class="style6">"Elsa"</span><span class="style10">,</span><span class="style4">56.6</span><span
class="style10">} };
    </span><span class="style16">vector</span><span class="style10">&lt;</span><span
class="style11">iter_t</span><span class="style10">&gt; </span><span class="style11">Ix_name</span><span
class="style10">, </span><span class="style11">Ix_weight </span><span class="style10">;

    </span><span class="style5">for </span><span class="style10">( </span><span
class="style11">iter_t it</span><span class="style10">= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() ; </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">)
    {   </span><span class="style11">Ix_name</span><span class="style10">.</span><span
class="style16">push_back </span><span class="style10">( </span><span class="style11">it</span><span
class="style10">);
        </span><span class="style11">Ix_weight</span><span class="style10">.</span><span
class="style16">push_back</span><span class="style10">( </span><span class="style11">it</span><span
class="style10">);
    };

    </span><span class="style5">typedef </span><span class="style11">less_ptr_no_null </span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">, </span><span
class="style11">cmp_name</span><span class="style10">&gt;     </span><span class="style11">compare_name </span><span
class="style10">;
    </span><span class="style5">typedef </span><span class="style11">less_ptr_no_null </span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">, </span><span
class="style11">cmp_weight</span><span class="style10">&gt;   </span><span class="style11">compare_weight </span><span
class="style10">;

    </span><span class="style11">hpx_sort</span><span class="style10">::</span><span
class="style16">sort </span><span class="style10">(</span><span class="style11">hpx</span><span
class="style10">::</span><span class="style11">parallel</span><span class="style10">::</span><span
class="style11">v1</span><span class="style10">::</span><span class="style11">seq</span><span
class="style10">,
                    </span><span class="style11">Ix_name</span><span class="style10">.</span><span
class="style16">begin</span><span class="style10">()  , </span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">()  , </span><span
class="style11">compare_name  </span><span class="style10">());
    </span><span class="style11">hpx_sort</span><span class="style10">::</span><span
class="style16">sort </span><span class="style10">(</span><span class="style11">hpx</span><span
class="style10">::</span><span class="style11">parallel</span><span class="style10">::</span><span
class="style11">v1</span><span class="style10">::</span><span class="style11">seq</span><span
class="style10">,
                    </span><span class="style11">Ix_weight</span><span class="style10">.</span><span
class="style16">begin</span><span class="style10">(), </span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">(), </span><span
class="style11">compare_weight</span><span class="style10">());

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by number \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">)
        </span><span class="style16">cout</span><span class="style10">&lt;&lt;(*</span><span
class="style11">it</span><span class="style10">);

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by name \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">)
        </span><span class="style16">cout</span><span class="style10">&lt;&lt;(*(*</span><span
class="style11">it</span><span class="style10">));

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by weight \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">)
        </span><span class="style16">cout</span><span class="style10">&lt;&lt;(*(*</span><span
class="style11">it</span><span class="style10">));

    </span><span class="style5">return </span><span class="style11">hpx</span><span
class="style10">::</span><span class="style11">finalize</span><span class="style10">();
};</span></span></code></pre>
          <br />
          <span class="style9"> </span> </div>
        <br />
         The output of the program is<br />
        <br />
        <div class="caja_codigo"> <br />
          Printing sorted by number <br />
          1 - Peter - 85.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          4 - Elsa - 56.6<br />
          Printing sorted by name <br />
          4 - Elsa - 56.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          1 - Peter - 85.6<br />
          Printing sorted by weight <br />
          4 - Elsa - 56.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          1 - Peter - 85.6<br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <img align="justify" src="file:///home/francisco/Projects/Sort/Boost_dev/doc/img/paso3.png"
          alt="" /></div>
      <a title="benchmark.html" href="benchmark.html" style="float:right"><img alt="link to benchmark page"
          src="img/next.png" /></a> <a title="index.html" href="index.html" style="float:right"><img
          alt="go to head of the page" src="img/up.png" /></a> 
      <table width="100%" xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision">
        <tbody>
          <tr>
            <td align="left">
              <p><small>Last revised: <br />
                </small></p>
            </td>
            <td> <br />
            </td>
          </tr>
        </tbody>
      </table>
      <hr />
      <div id="footer">
        <div id="footer-left">
          <div id="copyright">
            <p><span style="font-style: italic;">Copyright Francisco Jose Tapia
                2015.</span></p>
            <span style="font-style: italic;"> </span></div>
          <span style="font-style: italic;"> </span>
          <div id="license">
            <p><span style="font-style: italic;">Distributed under the <a href="/LICENSE_1_0.txt"
                  class="internal">Boost Software License, Version 1.0</a>.</span></p>
          </div>
          <span style="font-style: italic;"> </span></div>
        <span style="font-style: italic;"> </span> </div>
    </div>
  </body>
</html>
