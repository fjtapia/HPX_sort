<p><img alt="HPX icon" src="doc/files/hpx.png"></p>

<h1 id="hpxsort">HPX_sort</h1>

<h2 id="httpsgithubcomfjtapiahpxsort"> <a href="https://github.com/fjtapia/HPX_sort">https://github.com/fjtapia/HPX_sort</a></h2>

<p>The <strong>HPX sort</strong>, had been designed for to be included in the <a href="https://github.com/STEllAR-GROUP/hpx">HPX Library</a></p>

<p>HPX is a general purpose C++ runtime system for parallel and distributed applications of any scale. The goal of HPX is to create a high quality, freely available, open source implementation of the ParalleX model for conventional systems, such as classic Linux based Beowulf clusters or multi-socket highly parallel SMP nodes.</p>

<p>This library provide the sort algorithms in a single thread and parallel versions for that Library.</p>

<p>The algorithms <strong>use an comparison object</strong>, in the same way than the sort algorithms of the standard library. If you don’t define it, by default is std::less object, using internally the operator &lt; for to do the comparison.</p>

<p>The algorithms are <strong>exception safe</strong>, it means,  the exceptions generated by the algorithms guarantee the integrity of the objects to sort , but not their relative order. If the exception is generated inside the objects (in the move or in the copy constructor.. ) the results can be unpredictable.</p>

<p>For to select the single thread and the parallel version, these algorithms use the execution policy, as described in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4071.htm">Working Draft, Technical Specification for C++ Extensions for Parallelism</a> . If you want a simplified version you can find in <a href="http://en.cppreference.com/w/cpp/experimental/parallelism">cpp reference</a>.</p>

<p><strong>This library is include only</strong>. Don’t need to link with any static or dynamic library. Don’t have  dependence of any other files, variables or libraries or any other external libraries. For to use, only need a to include the files of the boost/sort/parallel folder, any more.</p>

<p>This table provide you a brief description of the sort algorithms of the library.</p>

<table>
<thead>
<tr>
  <th>Algorithm</th>
  <th>Parallel</th>
  <th>Stable</th>
  <th>Additional memory</th>
  <th>Best, average, and worst case</th>
</tr>
</thead>
<tbody><tr>
  <td>sort</td>
  <td>no</td>
  <td>no</td>
  <td>Log N</td>
  <td>NLogN, NLogN, NLogN</td>
</tr>
<tr>
  <td>stable_sort</td>
  <td>no</td>
  <td>yes</td>
  <td>N / 2</td>
  <td>NLogN, NLogN, NLogN</td>
</tr>
<tr>
  <td>sort</td>
  <td>yes</td>
  <td>no</td>
  <td>1024*NThreads</td>
  <td>NLogN, NLogN, NLogN</td>
</tr>
<tr>
  <td>stable_sort</td>
  <td>yes</td>
  <td>yes</td>
  <td>N / 2</td>
  <td>NLogN, NLogN, NLogN</td>
</tr>
<tr>
  <td>sample_sort</td>
  <td>yes</td>
  <td>yes</td>
  <td>N</td>
  <td>NLogN, NLogN, NLogN</td>
</tr>
</tbody></table>


<p>In this Parallel library, you can find <strong>stable and not stable sort</strong> algorithms, in a <strong>single thread and parallel</strong> version.</p>

<p>This version have a <strong>new non stable parallel_sort algorithm</strong> <em>( internally named Block Indirect)</em>, created for processors connected with <strong>shared memory</strong>.</p>

<p>In the parallel sorting algorithms, we can find algorithms <strong>fast with a small number of threads</strong>, but with a great number of HW threads , show their lacks</p>

<ul>
<li>Intel Threading Building Blocks (TBB)</li>
<li>Microsoft PPL Parallel Sort).</li>
</ul>

<p>And others not so fast with small number of HW threads, and <strong>fast with many threads</strong>. These algorithms use an additional memory of the same size than the data.</p>

<ul>
<li>GCC Parallel Sort (based on OpenMP)</li>
<li>Microsoft PPL Parallel Buffered Sort</li>
</ul>

<p>This generate an <strong>undesirable duality</strong>. With a small number of threads use one algorithm, and with a big number use other. Due this, the SW designed for a small machine is inadequate for a big machine and vice versa. But the main problem, for the algorithms for a big number of HW threads is the memory used, usually of the same size than the data.</p>

<p>This <strong>new parallel sort algorithm</strong> permit <strong>eliminate the duality</strong>.  With  <strong>many threads</strong>, have similar performance than GCC Parallel Sort, and with  <strong>a few threads</strong> have similar performance than TBB, with the <strong>additional advantage</strong> of the <strong>small memory consumption</strong>.</p>

<p>The algorithm use as <strong>auxiliary memory a 1024 elements</strong> for each thread. The worst case for the algorithm is when have very big elements and many threads. With big elements (512 bytes), and 32 threads, The memory measured was:</p>

<table>
<thead>
<tr>
  <th>Algorithm</th>
  <th>Memory used in MB</th>
</tr>
</thead>
<tbody><tr>
  <td>GCC Parallel Sort (OpenMP)</td>
  <td>1565 MB</td>
</tr>
<tr>
  <td>Threading Building Blocks (TBB)</td>
  <td>783 MB</td>
</tr>
<tr>
  <td>Block Indirect Sort</td>
  <td>814 MB</td>
</tr>
</tbody></table>


<p><em>This <strong>new parallel_sort algorithm had been  created and implemented specifically for this library</strong> by the author.</em></p>

<p><em>You can obtain more information in the Documantation Page of the Project  </em> <a href="index.html"> index.html</a></p>

<p><em>If you  are interested in a brief description of the algorithm, you can find in the next link</em>  <br>
<a href="block_indirect_sort_brief_en.pdf">block_indirect_sort_brief_en.pdf</a></p>

<p><em>If you  are interested in a detailed description of the algorithm, you can find in the next link</em>  <br>
<a href="block_indirect_sort_en.pdf">block_indirect_sort_en.pdf</a></p>

<h2 id="installation">Installation </h2>

<ul>
<li>This library is <strong>include only</strong>. <br>
<ul><li>Don’t need to link with any static or dynamic library.</li>
<li>Don’t have  dependence of any other libraries.</li>
<li>For to use, only need a to include the file hpx/parallel/sort/sort.hpp,.  </li></ul></li>
</ul>

<h2 id="author-and-copyright">Author and Copyright</h2>

<p>This library had been create for to be integrated in the <a href="https://github.com/STEllAR-GROUP/hpx">HPX</a> library.</p>

<p>It’s pending of revision, and due this can suffer some changes until the final version. You can find in  <a href="https://github.com/fjtapia/HPX_sort">https://github.com/fjtapia/HPX_sort</a></p>

<p>This algorithm had been ideate, designed and implemented beginning from zero. After read hundreds of articles and books, I didn’t find any similar. If someone knows something about this or something similar, please, say me.</p>

<p>Anyway, the important is not the author, is provide a fast, robust, and easy to use algorithm to the community of programmers.</p>

<p>Copyright 2016  <a>Francisco Tapia <em>(fjtapia@gmail.com)</em> </a> <br>
Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0. </a>  (See <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</p>